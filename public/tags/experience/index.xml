<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Experience on 知乎</title>
    <link>http://localhost:1313/tags/experience/</link>
    <description>Recent content in Experience on 知乎</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 15 Mar 2022 21:55:00 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/experience/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>druid配置数据库连接使用密文密码</title>
      <link>http://localhost:1313/Druid-configures-database-connections-to-use-ciphertext-passwords.html</link>
      <pubDate>Tue, 15 Mar 2022 21:55:00 +0800</pubDate>
      <guid>http://localhost:1313/Druid-configures-database-connections-to-use-ciphertext-passwords.html</guid>
      <description>&lt;p&gt;druid配置数据库连接使用密文密码&#xA;spring使用druid配置dataSource片段代码&#xA;dataSource配置&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&#xD;&#xA;&amp;lt;!-- 基于Druid数据库链接池的数据源配置 --&amp;gt;&#xD;&#xA;&amp;lt;bean id=&amp;#34;dataSource&amp;#34; class=&amp;#34;com.alibaba.druid.pool.DruidDataSource&amp;#34; init-method=&amp;#34;init&amp;#34; destroy-method=&amp;#34;close&amp;#34;&amp;gt;&#xD;&#xA;&amp;lt;!-- 基本属性driverClassName、 url、user、password --&amp;gt;&#xD;&#xA;&amp;lt;property name=&amp;#34;driverClassName&amp;#34; value=&amp;#34;com.mysql.jdbc.Driver&amp;#34; /&amp;gt;&#xD;&#xA;&amp;lt;property name=&amp;#34;url&amp;#34; value=&amp;#34;${jdbc.url}&amp;#34; /&amp;gt;&#xD;&#xA;&amp;lt;property name=&amp;#34;username&amp;#34; value=&amp;#34;${jdbc.username}&amp;#34; /&amp;gt;&#xD;&#xA;&amp;lt;property name=&amp;#34;password&amp;#34; value=&amp;#34;${jdbc.password}&amp;#34; /&amp;gt;&#xD;&#xA;&amp;lt;!-- 配置初始化大小、最小、最大 --&amp;gt;&#xD;&#xA;&amp;lt;!-- 通常来说，只需要修改initialSize、minIdle、maxActive --&amp;gt;&#xD;&#xA;&amp;lt;property name=&amp;#34;initialSize&amp;#34; value=&amp;#34;2&amp;#34; /&amp;gt;&#xD;&#xA;&amp;lt;property name=&amp;#34;minIdle&amp;#34; value=&amp;#34;2&amp;#34; /&amp;gt;&#xD;&#xA;&amp;lt;property name=&amp;#34;maxActive&amp;#34; value=&amp;#34;30&amp;#34; /&amp;gt;&#xD;&#xA;&amp;lt;property name=&amp;#34;testWhileIdle&amp;#34; value=&amp;#34;false&amp;#34; /&amp;gt;&#xD;&#xA;&#xD;&#xA;&amp;lt;!-- 配置获取连接等待超时的时间 --&amp;gt;&#xD;&#xA;&amp;lt;property name=&amp;#34;maxWait&amp;#34; value=&amp;#34;5000&amp;#34; /&amp;gt;&#xD;&#xA;&amp;lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&amp;gt;&#xD;&#xA;&amp;lt;property name=&amp;#34;minEvictableIdleTimeMillis&amp;#34; value=&amp;#34;30000&amp;#34; /&amp;gt;&#xD;&#xA;&amp;lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&amp;gt;&#xD;&#xA;&amp;lt;property name=&amp;#34;timeBetweenEvictionRunsMillis&amp;#34; value=&amp;#34;60000&amp;#34; /&amp;gt;&#xD;&#xA;&amp;lt;!-- 解密密码必须要配置的项 --&amp;gt;&#xD;&#xA;&amp;lt;property name=&amp;#34;filters&amp;#34; value=&amp;#34;config&amp;#34; /&amp;gt;&#xD;&#xA;&amp;lt;property name=&amp;#34;connectionProperties&amp;#34; value=&amp;#34;config.decrypt=true&amp;#34; /&amp;gt;&#xD;&#xA;&amp;lt;/bean&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;jdbc.properties&lt;/p&gt;</description>
    </item>
    <item>
      <title>freemarker 使用记录</title>
      <link>http://localhost:1313/how-to-use-freemarker.html</link>
      <pubDate>Tue, 15 Mar 2022 21:55:00 +0800</pubDate>
      <guid>http://localhost:1313/how-to-use-freemarker.html</guid>
      <description>&lt;h2 id=&#34;1long类型显示带逗号&#34;&gt;1、Long类型显示带逗号&lt;/h2&gt;&#xA;&lt;p&gt;如 id=1,234;&lt;/p&gt;&#xA;&lt;p&gt;解决的方案是，增加配置 &lt;strong&gt;number_format: &amp;lsquo;#&amp;rsquo;&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;spring:&#xD;&#xA;    profiles:&#xD;&#xA;        active: &amp;#39;@profileActive@&amp;#39;&#xD;&#xA;    application:&#xD;&#xA;        name: blog-web&#xD;&#xA;    freemarker:&#xD;&#xA;        allow-request-override: false&#xD;&#xA;        allow-session-override: false&#xD;&#xA;        cache: false&#xD;&#xA;        charset: UTF-8&#xD;&#xA;        check-template-location: true&#xD;&#xA;        content-type: text/html&#xD;&#xA;        enabled: true&#xD;&#xA;        expose-request-attributes: false&#xD;&#xA;        expose-session-attributes: false&#xD;&#xA;        expose-spring-macro-helpers: true&#xD;&#xA;        prefer-file-system-access: true&#xD;&#xA;        suffix: .ftl&#xD;&#xA;        template-loader-path: classpath:/templates/&#xD;&#xA;        settings:&#xD;&#xA;            template_update_delay: 0&#xD;&#xA;            default_encoding: UTF-8&#xD;&#xA;            classic_compatible: true&#xD;&#xA;            number_format: &amp;#39;#&amp;#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2boolean类型false返回空&#34;&gt;2、boolean类型false返回空&lt;/h2&gt;&#xA;&lt;p&gt;如：var flag=; //当false的时候为空，true的时候为空&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var isPrivate = ${article.private};//原始的写法&#xD;&#xA;var isPrivate = ${article.private?string(&amp;#34;true&amp;#34;,&amp;#34;false&amp;#34;)};//改进的写法&#xD;&#xA;&#xD;&#xA;if(isPrivate || isPrivate == &amp;#39;true&amp;#39;) {&#xD;&#xA;      $(&amp;#34;#lockModal&amp;#34;).modal(&amp;#39;show&amp;#39;)&#xD;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;借用网上的一段解释&lt;/p&gt;</description>
    </item>
    <item>
      <title>java spi入门</title>
      <link>http://localhost:1313/Getting-started-with-java-spi.html</link>
      <pubDate>Tue, 15 Mar 2022 21:55:00 +0800</pubDate>
      <guid>http://localhost:1313/Getting-started-with-java-spi.html</guid>
      <description>&lt;h3 id=&#34;1什么是spi&#34;&gt;1、什么是SPI&lt;/h3&gt;&#xA;&lt;p&gt;​&#x9;SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件。 SPI的作用就是为这些被扩展的API寻找服务实现。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2spi和api的区别&#34;&gt;2、SPI和API的区别&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;spi &lt;strong&gt;Service Provider Interface&lt;/strong&gt; &lt;code&gt;调用方&lt;/code&gt;来制定接口，&lt;code&gt;实现方&lt;/code&gt;来针对接口来实现不同的实现。&lt;code&gt;调用方&lt;/code&gt;来选择自己需要的&lt;code&gt;实现方&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;API Application Programming Interface&#xA;大多数情况下，都是实现方来制定接口并完成对接口的不同实现，调用方仅仅依赖却无权选择不同实现。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://imgchr.com/i/DCEICq&#34;&gt;&#xD;&#xA;        &lt;img class=&#34;mx-auto&#34; alt=&#34;SPI与API的区别&#34; src=&#34;https://s3.ax1x.com/2020/11/14/DCEICq.png&#34; /&gt;   &#xD;&#xA;    &lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>java swing总结</title>
      <link>http://localhost:1313/java-swingSummary.html</link>
      <pubDate>Tue, 15 Mar 2022 21:55:00 +0800</pubDate>
      <guid>http://localhost:1313/java-swingSummary.html</guid>
      <description>&lt;h3 id=&#34;1swing使用体验&#34;&gt;1、swing使用体验&lt;/h3&gt;&#xA;&lt;p&gt;刚开始出于好奇心想体验下java开发的桌面程序，网上搜索了一把，主流的就swing和javafx。一番体验和对比。最终还是倒向了swing.对于一个后端开发来说，swing绝对是完胜。理解好几个重要的概念，界面的事情交给框架和三方。&lt;/p&gt;&#xA;&lt;p&gt;下面从几个维度对这两个技术简单的对比一下：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;          &lt;th&gt;swing&lt;/th&gt;&#xA;          &lt;th&gt;javafx&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;界面&lt;/td&gt;&#xA;          &lt;td&gt;界面一般&lt;/td&gt;&#xA;          &lt;td&gt;理论上完全可以自定义，因为支持css&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;技术新颖&lt;/td&gt;&#xA;          &lt;td&gt;接近20年的历史&lt;/td&gt;&#xA;          &lt;td&gt;5年左右的历史&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;技术成熟度&lt;/td&gt;&#xA;          &lt;td&gt;久经考验，文档丰富&lt;/td&gt;&#xA;          &lt;td&gt;尚在孵化中&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;市面接纳度&lt;/td&gt;&#xA;          &lt;td&gt;老牌的都在用&lt;/td&gt;&#xA;          &lt;td&gt;没见到几个产品再用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;2swing-ui优化&#34;&gt;2、swing UI优化&lt;/h3&gt;&#xA;&lt;p&gt;swing默认的ui的确有点难看，但是它提供了一个lookandfeel来支持ui的优化。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java线上故障排查技巧</title>
      <link>http://localhost:1313/Java-Online-Troubleshooting-Tips.html</link>
      <pubDate>Tue, 15 Mar 2022 21:55:00 +0800</pubDate>
      <guid>http://localhost:1313/Java-Online-Troubleshooting-Tips.html</guid>
      <description>&lt;h3 id=&#34;1分类&#34;&gt;1、分类&lt;/h3&gt;&#xA;&lt;p&gt;线上故障主要会包括 CPU、磁盘、内存以及网络问题，而大多数故障可能会包含不止一个层面的问题，所以进行排查时候尽量四个方面依次排查一遍。&lt;/p&gt;&#xA;&lt;p&gt;同时例如 jstack、jmap 等工具也是不囿于一个方面的问题的，基本上出问题就是 df、free、top 三连，然后依次 jstack、jmap 伺候，具体问题具体分析即可。&lt;/p&gt;</description>
    </item>
    <item>
      <title>故障处理总纲</title>
      <link>http://localhost:1313/Troubleshooting-outline.html</link>
      <pubDate>Tue, 15 Mar 2022 21:55:00 +0800</pubDate>
      <guid>http://localhost:1313/Troubleshooting-outline.html</guid>
      <description>&lt;h3 id=&#34;1前言&#34;&gt;1、前言&lt;/h3&gt;&#xA;&lt;p&gt;没有完美的程序，是程序都有bug,都有容量限制。所以出现故障也在情理之中，那么面对突如其来的bug,我们该如何应对呢？这是一个值得思考的问题？&lt;/p&gt;&#xA;&lt;h3 id=&#34;2核心原则&#34;&gt;2、核心原则&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;将正在发生或已发生故障的损害程度减轻到最低-&lt;strong&gt;恢复服务&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;而与之对应的错误做法是成谜于追求破案的情结之中，无法自拔，而这样做的结果往往都是时间过去了，原因没找到，故障进一步升级，这个需要引起重视。&lt;/p&gt;</description>
    </item>
    <item>
      <title>故障处理系列-httpclient 3.x的bug引发的惨案</title>
      <link>http://localhost:1313/Troubleshooting-series-tragedy-caused-by-the-bug-of-httpclient-3.x.html</link>
      <pubDate>Tue, 15 Mar 2022 21:55:00 +0800</pubDate>
      <guid>http://localhost:1313/Troubleshooting-series-tragedy-caused-by-the-bug-of-httpclient-3.x.html</guid>
      <description>&lt;h3 id=&#34;1故障现象描述&#34;&gt;1、故障现象描述&lt;/h3&gt;&#xA;&lt;p&gt;调用链路是 A-&amp;gt;B-&amp;gt;C&lt;/p&gt;&#xA;&lt;p&gt;目前出故障的是B服务。A是网关，C是底层服务&lt;/p&gt;&#xA;&lt;p&gt;故障的现象是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A对外出现大量的504&lt;/li&gt;&#xA;&lt;li&gt;B的线程数暴增&lt;/li&gt;&#xA;&lt;li&gt;B的流量骤减，一段时间趋近于0&lt;/li&gt;&#xA;&lt;li&gt;C的请求响应无明显异常&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2故障分析&#34;&gt;2、故障分析&lt;/h3&gt;&#xA;&lt;p&gt;从B的流量骤减至0，然后A大量504可以推测出可能是A把B给熔断了，根据这个思路排查，最终定位到了B的熔断策略中有一个最大线程数的限制，这个跟B的线程数暴增是吻合的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>故障处理系列-大文件引发OOM</title>
      <link>http://localhost:1313/Troubleshooting-Series-Large-File-Causes-OOM.html</link>
      <pubDate>Tue, 15 Mar 2022 21:55:00 +0800</pubDate>
      <guid>http://localhost:1313/Troubleshooting-Series-Large-File-Causes-OOM.html</guid>
      <description>&lt;h3 id=&#34;1场景还原&#34;&gt;1、场景还原&lt;/h3&gt;&#xA;&lt;p&gt;系统A是一个需要加载文件到内存中进行处理的系统&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大量的大文件并发请求过来&lt;/li&gt;&#xA;&lt;li&gt;收到大量的系统的内存告警&lt;/li&gt;&#xA;&lt;li&gt;收到大量的5xx告警，同时从监控可以看到大量的fullGC&lt;/li&gt;&#xA;&lt;li&gt;系统oom&lt;/li&gt;&#xA;&lt;li&gt;重启，过了3分钟故障再次发生&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2原因分析&#34;&gt;2、原因分析&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大量的大文件请求过来，导致系统中内存迅速消耗殆尽&lt;/li&gt;&#xA;&lt;li&gt;内存不够用触发fullGc&lt;/li&gt;&#xA;&lt;li&gt;频繁的gc导致系统卡顿，触发5xx&lt;/li&gt;&#xA;&lt;li&gt;gc无法维持内存的稳定，oom&lt;/li&gt;&#xA;&lt;li&gt;重启无法解决，是因为系统的是通过mq进行驱动的，重启能够是内存恢复，但是mq的重试机制又迅速点燃了这个故障，要想彻底解决，只能是清洗或过滤这一批异常数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;主要原因是系统层面未对这个大文件的场景进行考虑，超出了系统的处理能力。&lt;/p&gt;</description>
    </item>
    <item>
      <title>故障处理系列-数据清洗堵塞mq</title>
      <link>http://localhost:1313/Troubleshooting-Series-Data-Cleaning-and-Blocking-MQ.html</link>
      <pubDate>Tue, 15 Mar 2022 21:55:00 +0800</pubDate>
      <guid>http://localhost:1313/Troubleshooting-Series-Data-Cleaning-and-Blocking-MQ.html</guid>
      <description>&lt;h3 id=&#34;1故障还原&#34;&gt;1、故障还原&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;系统负载迅速升高&lt;/li&gt;&#xA;&lt;li&gt;大量mq的发送被限流，影响到了核心业务（有强依赖mq驱动的）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2根因分析&#34;&gt;2、根因分析&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;上游的一个业务触发了系统的数据清洗&lt;/li&gt;&#xA;&lt;li&gt;清理的数据比较多，清洗的逻辑中需要对外发送大量的广播&lt;/li&gt;&#xA;&lt;li&gt;mq的发送频率过快，大量的超时，进而被熔断&lt;/li&gt;&#xA;&lt;li&gt;大量的mq无法完成发送&lt;/li&gt;&#xA;&lt;li&gt;上游大量基于mq驱动的业务受阻&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;3处理办法&#34;&gt;3、处理办法&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;清洗数据为非核心业务，可以控制处理时间、策略。避免对核心业务的冲击&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
