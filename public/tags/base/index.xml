<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Base on 知乎</title>
    <link>http://localhost:1313/tags/base/</link>
    <description>Recent content in Base on 知乎</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 15 Mar 2022 21:55:00 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/base/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GC调优参数</title>
      <link>http://localhost:1313/GC-tuning-parameters.html</link>
      <pubDate>Tue, 15 Mar 2022 21:55:00 +0800</pubDate>
      <guid>http://localhost:1313/GC-tuning-parameters.html</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;原文地址： &lt;a href=&#34;https://juejin.im/post/5c94a123f265da610916081f&#34;&gt;https://juejin.im/post/5c94a123f265da610916081f&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;jvm-配置常用参数&#34;&gt;JVM 配置常用参数&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;堆参数；&lt;/li&gt;&#xA;&lt;li&gt;回收器参数；&lt;/li&gt;&#xA;&lt;li&gt;项目中常用配置；&lt;/li&gt;&#xA;&lt;li&gt;常用组合；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;堆参数&#34;&gt;堆参数&lt;/h3&gt;&#xA;&lt;p&gt;&#xD;&#xA;        &lt;img class=&#34;mx-auto&#34; alt=&#34;img&#34; src=&#34;https://ask.qcloudimg.com/http-save/yehe-1130324/975rk4d0wx.jpeg?imageView2/2/w/1620&#34; /&gt;   &#xD;&#xA;    &lt;/p&gt;&#xA;&lt;h3 id=&#34;回收器参数&#34;&gt;回收器参数&lt;/h3&gt;&#xA;&lt;p&gt;&#xD;&#xA;        &lt;img class=&#34;mx-auto&#34; alt=&#34;img&#34; src=&#34;https://ask.qcloudimg.com/http-save/yehe-1130324/34nzellt71.jpeg?imageView2/2/w/1620&#34; /&gt;   &#xD;&#xA;    &lt;/p&gt;&#xA;&lt;p&gt;如上表所示，目前&lt;strong&gt;主要有串行、并行和并发三种&lt;/strong&gt;，对于大内存的应用而言，串行的性能太低，因此使用到的主要是并行和并发两种。并行和并发 GC 的策略通过 &lt;code&gt;UseParallelGC &lt;/code&gt;和&lt;code&gt; UseConcMarkSweepGC&lt;/code&gt; 来指定，还有一些细节的配置参数用来配置策略的执行方式。例如：&lt;code&gt;XX:ParallelGCThreads&lt;/code&gt;， &lt;code&gt;XX:CMSInitiatingOccupancyFraction&lt;/code&gt; 等。 通常：Young 区对象回收只可选择并行（耗时间），Old 区选择并发（耗 CPU）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>java内存优化的常见方法</title>
      <link>http://localhost:1313/java-memory-optimization.html</link>
      <pubDate>Tue, 15 Mar 2022 21:55:00 +0800</pubDate>
      <guid>http://localhost:1313/java-memory-optimization.html</guid>
      <description>&lt;h2 id=&#34;1慎用new&#34;&gt;1、慎用new&lt;/h2&gt;&#xA;&lt;p&gt;&#xD;&#xA;        &lt;img class=&#34;mx-auto&#34; alt=&#34;优化无极限&#34; src=&#34;https://static.gzcx.net/oneblog/20210724220825605.png-94rg002&#34; /&gt;   &#xD;&#xA;    &#xA;new就意味着会分配对应的内存空间。利用jdk本身的变量&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;错误&lt;/th&gt;&#xA;          &lt;th&gt;建议&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;new Boolean(true)&lt;/td&gt;&#xA;          &lt;td&gt;Boolean.TRUE&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;new Integer()&lt;/td&gt;&#xA;          &lt;td&gt;Integer.valueOf(int i)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;2string操作&#34;&gt;2、String操作&lt;/h2&gt;&#xA;&lt;p&gt;用StringBuffer替换+操作&lt;/p&gt;&#xA;&lt;h2 id=&#34;3容易忽略的细节&#34;&gt;3、容易忽略的细节&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;细节&lt;/th&gt;&#xA;          &lt;th&gt;建议&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;HashMap&lt;/td&gt;&#xA;          &lt;td&gt;初始化指定大小&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;for循环减少变量的计算&lt;/td&gt;&#xA;          &lt;td&gt;for( inti= 0,len= list.size();i&amp;lt;len;i++)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;对象尽量在确定的范围内创建&lt;/td&gt;&#xA;          &lt;td&gt;if(i== 1){A a = newA();}&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;final中及时释放资源&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;try cath&lt;/td&gt;&#xA;          &lt;td&gt;不在循环内部使用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Map遍历&lt;/td&gt;&#xA;          &lt;td&gt;使用Entry操作&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;4其他的有效的建议&#34;&gt;4、其他的有效的建议&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;多使用单例&lt;/li&gt;&#xA;&lt;li&gt;减少static的使用&lt;/li&gt;&#xA;&lt;li&gt;内部多使用基本的数据类型&lt;/li&gt;&#xA;&lt;li&gt;尽量使用位运算。int num = a * 4;可改写 intn um = a &amp;laquo; 2;&lt;/li&gt;&#xA;&lt;li&gt;HashMap、StringBuffer初始化尽量指定大小。避免扩容复制带来的消耗&lt;/li&gt;&#xA;&lt;li&gt;无效的局部变量，尽早显示指定null&lt;/li&gt;&#xA;&lt;li&gt;数组的拷贝尽量使用系统函数 &lt;strong&gt;System.arraycopy ()&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;高频使用对用使用缓存&lt;/li&gt;&#xA;&lt;li&gt;慎用异常控制流程。因为stack track消耗不小&lt;/li&gt;&#xA;&lt;li&gt;try catch&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>juc介绍</title>
      <link>http://localhost:1313/java-juc.html</link>
      <pubDate>Tue, 15 Mar 2022 21:55:00 +0800</pubDate>
      <guid>http://localhost:1313/java-juc.html</guid>
      <description>&lt;h2 id=&#34;1日常工作中的并发&#34;&gt;1、日常工作中的并发&lt;/h2&gt;&#xA;&lt;p&gt;今天的日程&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;jira待处理的任务两个&lt;/li&gt;&#xA;&lt;li&gt;完成测试环境的发布，通知测试开始验证&lt;/li&gt;&#xA;&lt;li&gt;钉钉联系客户了解问题发生的过程&lt;/li&gt;&#xA;&lt;li&gt;迭代新功能开发&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;实际过程中我们怎么做？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;先在发布平台上把发布的过程触发起来；&lt;/li&gt;&#xA;&lt;li&gt;钉钉给客户发消息询问问题详情；&lt;/li&gt;&#xA;&lt;li&gt;打开jira,开始分析问题&lt;/li&gt;&#xA;&lt;li&gt;过一段时间回头看下发布的过程是否已经完成了，客户是否有回复&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;并发充分利用cpu资源，提高程序的响应速度&lt;/p&gt;</description>
    </item>
    <item>
      <title>jvm 知识点汇总</title>
      <link>http://localhost:1313/Summary-of-jvm-knowledge-points.html</link>
      <pubDate>Tue, 15 Mar 2022 21:55:00 +0800</pubDate>
      <guid>http://localhost:1313/Summary-of-jvm-knowledge-points.html</guid>
      <description>&lt;p&gt;无论什么级别的Java从业者，JVM都是进阶时必须迈过的坎。不管是工作还是面试中，JVM都是必考题。如果不懂JVM的话，薪酬会非常吃亏（近70%的面试者挂在JVM上了）。&lt;/p&gt;&#xA;&lt;p&gt;掌握了JVM机制，就等于学会了深层次解决问题的方法。对于Java开发者而言，只有熟悉底层虚拟机的运行机制，才能通过JVM日志深入到字节码的层次去分析排查问题，发现隐性的系统缺陷，进而提升系统性能。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
